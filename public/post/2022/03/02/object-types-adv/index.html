<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Fundamental object types in R III: Factors, matrices, and data frames | Data Science (SpSe22)</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/material/">Material</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Fundamental object types in R III: Factors, matrices, and data frames</span></h1>
<h2 class="author">Claudius Gräbner-Radkowitsch</h2>
<h2 class="date">2022/03/02</h2>
</div>

<main>
<p>Download this post as <a href="index.pdf">PDF</a></p>
<ul>
<li>TOC</li>
<li>Picture with overview</li>
</ul>
<h1 id="introfactors">Faktoren</h1>
<p>Faktoren werden verwendet um ordinale oder kategoriale Daten darzustellen.
Ein Faktor kann nur einen von mehreren vorher definierten Werten annehmen, so
genannten <em>Levels</em>.
Faktoren werden über die Funktion <code>factor()</code> erstellt.
Sie nimmt als erstes Argument die Werte für den Faktor:</p>
<pre><code class="language-r">x &lt;- c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;)
x &lt;- factor(c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;))
x
</code></pre>
<pre><code>## [1] Frau Mann Frau
## Levels: Frau Mann
</code></pre>
<p>Wenn wir Levels definieren wollen, die aber aktuell noch keine Ausprägung
haben können wir dies mit dem Argument <code>levels</code> bewerkstelligen:</p>
<pre><code class="language-r">x &lt;- c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;)
x &lt;- factor(c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;), 
            levels=c(&quot;Divers&quot;,&quot;Frau&quot;, &quot;Mann&quot;))
x
</code></pre>
<pre><code>## [1] Frau Mann Frau
## Levels: Divers Frau Mann
</code></pre>
<p>Wenn wir das Argument <code>levels</code> verwenden werden dort nicht genannte
Ausprägungen den Wert <code>NA</code> erhalten:</p>
<pre><code class="language-r">x &lt;- c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;)
x &lt;- factor(c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;, &quot;Divers&quot;), 
            levels=c(&quot;Frau&quot;, &quot;Mann&quot;))
x
</code></pre>
<pre><code>## [1] Frau Mann Frau &lt;NA&gt;
## Levels: Frau Mann
</code></pre>
<p>Die Reihenfolge der einzelnen Levels spielt meist keine Rolle.
Bei ordinalen Daten möchten wir aber eine sinnvolle Wertigkeit der
Ausprägungen sicherstellen.
Das geht mit der Funktion <code>factor()</code> und dem Argument <code>ordered</code>:</p>
<pre><code class="language-r">x &lt;- c(&quot;Hoch&quot;, &quot;Hoch&quot;, &quot;Gering&quot;, &quot;Hoch&quot;)
x &lt;- factor(x, 
            levels = c(&quot;Gering&quot;, &quot;Mittel&quot;, &quot;Hoch&quot;), 
            ordered = TRUE)
x
</code></pre>
<pre><code>## [1] Hoch   Hoch   Gering Hoch  
## Levels: Gering &lt; Mittel &lt; Hoch
</code></pre>
<p>Häufig handelt es sich bei den Ausprägungen von Faktoren um Wörter, also
Objekte vom Type <code>character</code>.
Technisch gesehen werden Faktoren aber als <code>integer</code> gespeichert: um
Speicherplatz zu sparen wird jedem Level auf dem Computer eine ganze Zahl
zugewiesen, die dann auf den eigentlichen Wert gemapt wird. Gerade wenn die
Ausprägungen als solche große Zahlen oder lange Wörter sind spart das Speicher,
weil diese Ausprägungen nur einmal gespeichert werden müssen, und jedes Element
des Fakors nur noch eine einfache Zahl ist.
Daher gibt <code>typeof()</code> für Faktoren auch <code>integer</code> aus:</p>
<pre><code class="language-r">x &lt;- factor(c(&quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;), 
            levels=c(&quot;Mann&quot;, &quot;Frau&quot;, &quot;Divers&quot;))
typeof(x)
</code></pre>
<pre><code>## [1] &quot;integer&quot;
</code></pre>
<p>Um zu überprüfen ob es sich bei einem Objekt um einen Faktor handelt verwenden
wir die Funktion <code>is.factor()</code>:</p>
<pre><code class="language-r">is.factor(x)
</code></pre>
<pre><code>## [1] TRUE
</code></pre>
<p>Manche Operationen, die für <code>integer</code> definiert sind, funktionieren bei Faktoren
aber nicht, z.B. Addition:</p>
<pre><code class="language-r">x[1] + x[2]
</code></pre>
<pre><code>## Warning in Ops.factor(x[1], x[2]): '+' not meaningful for factors
</code></pre>
<pre><code>## [1] NA
</code></pre>
<p>Dafür können wir andere nützliche Dinge mit Faktoren anstellen, z.B. die
absoluten Häufigkeiten über die Funktion <code>table()</code> anzeigen:</p>
<pre><code class="language-r">table(x)
</code></pre>
<pre><code>## x
##   Mann   Frau Divers 
##      1      2      0
</code></pre>
<p>Faktoren werden vor allem in der Arbeit mit ordinalen und kategorialen Daten
verwendet (siehe Kapitel <a href="#data"><strong>??</strong></a>).</p>
<h1 id="intro-matrix">Matrizen</h1>
<p>Bei Matrizen handelt es sich um zweidimensionale Objekte mit Zeilen und Spalten,
bei denen es sich jeweils um atomare Vektoren handelt.</p>
<p><strong>Erstellen von Matrizen</strong></p>
<p>Matrizen werden mit der Funktion <code>matrix()</code> erstellt.
Diese Funktion nimmt als erstes Argument die Elemente der Matrix und dann
die Spezifikation der Anzahl von Zeilen (<code>nrow</code>) und/oder der Anzahl von
Spalten (<code>ncol</code>):</p>
<pre><code class="language-r">m_1 &lt;- matrix(11:20, nrow = 5)
m_1
</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   11   16
## [2,]   12   17
## [3,]   13   18
## [4,]   14   19
## [5,]   15   20
</code></pre>
<p>Wir können die Zeilen und Spalten sowie einzelne Werte folgendermaßen extrahieren
und gegebenenfalls Ersetzungen vornehmen:</p>
<pre><code class="language-r">m_1[,1] # Erste Spalte
</code></pre>
<pre><code>## [1] 11 12 13 14 15
</code></pre>
<pre><code class="language-r">m_1[1,] # Erste Zeile
</code></pre>
<pre><code>## [1] 11 16
</code></pre>
<pre><code class="language-r">m_1[2,2] # Element [2,2]
</code></pre>
<pre><code>## [1] 17
</code></pre>
<blockquote>
<p><strong>Optionaler Hinweis:</strong> Matrizen sind weniger &lsquo;fundamental&rsquo; als atomare Vektoren.
Entsprechend gibt uns <code>typeof()</code> für eine Matrix auch den Typ der enthaltenen
atomaren Vektoren an:</p>
</blockquote>
<pre><code class="language-r">typeof(m_1)
</code></pre>
<pre><code>## [1] &quot;integer&quot;
</code></pre>
<blockquote>
<p>Um zu testen ob es sich bei einem Objekt um eine Matrix handelt verwenden wir
entsprechend <code>is.matrix()</code>:</p>
</blockquote>
<pre><code class="language-r">is.matrix(m_1)
</code></pre>
<pre><code>## [1] TRUE
</code></pre>
<pre><code class="language-r">is.matrix(2.0)
</code></pre>
<pre><code>## [1] FALSE
</code></pre>
<p>Die Grundlagen der Matrizenalgebra und ihre Implementierung in R wird später
in Kapitel <a href="#formalia"><strong>??</strong></a> erläutert.
Zudem gibt es im Internet zahlreiche gute Überblicksartikel zum Thema Matrizenalgebra
in R, z.B. <a href="https://www.statmethods.net/advstats/matrix.html">hier</a>
oder in größerem Umfang
<a href="https://www.math.uh.edu/~jmorgan/Math6397/day13/LinearAlgebraR-Handout.pdf">hier</a>.</p>
<h1 id="data-frames">Data Frames</h1>
<p>Der <code>data.frame</code> ist eine besondere Art von Liste und ist ein in der
Datenanalyse regelmäßig auftretender Datentyp.
Im Gegensatz zu einer normalen Liste müssen bei einem <code>data.frame</code> alle Elemente
die gleiche Länge aufweisen.
Das heißt man kann sich einen <code>data.frame</code> als eine rechteckig angeordnete Liste
vorstellen.</p>
<p>Wegen der engen Verwandschaft können wir einen <code>data.frame</code> direkt aus einer Liste
erstellen indem wir die Funktion <code>as.data.frame()</code> verwenden:</p>
<pre><code class="language-r">l_3 &lt;- list(
  &quot;a&quot; = 1:3,
  &quot;b&quot; = 4:6,
  &quot;c&quot; = 7:9
)
df_3 &lt;- as.data.frame(l_3)
</code></pre>
<p>Wenn wir R nach dem Typ von <code>df_3</code> fragen, sehen wir, dass es sich weiterhin um
eine Liste handelt:</p>
<pre><code class="language-r">typeof(df_3)
</code></pre>
<pre><code>## [1] &quot;list&quot;
</code></pre>
<p>Allerdings können wir testen ob <code>df_3</code> ein <code>data.frame</code> ist indem wir
<code>is.data.frame</code> benutzen:</p>
<pre><code class="language-r">is.data.frame(df_3)
</code></pre>
<pre><code>## [1] TRUE
</code></pre>
<pre><code class="language-r">is.data.frame(l_3)
</code></pre>
<pre><code>## [1] FALSE
</code></pre>
<p>Wenn wir <code>df_3</code> ausgeben sehen wir unmittelbar den Unterschied zur klassischen
Liste:</p>
<pre><code class="language-r">l_3
</code></pre>
<pre><code>## $a
## [1] 1 2 3
## 
## $b
## [1] 4 5 6
## 
## $c
## [1] 7 8 9
</code></pre>
<pre><code class="language-r">df_3
</code></pre>
<pre><code>##   a b c
## 1 1 4 7
## 2 2 5 8
## 3 3 6 9
</code></pre>
<p>Die andere Möglichkeit einen <code>data.frame</code> zu erstellen ist direkt über die
Funktion <code>data.frame()</code>, wobei es hier in der Regel ratsam ist das optionale
Argument <code>stringsAsFactors</code> auf <code>FALSE</code> zu setzen, da sonst Wörter in so
genannte Faktoren umgewandelt werden:^[Zur Geschichte dieses wirklich
ärgerlichen Verhaltens siehe
<a href="https://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/">diesen Blog</a>. Zwar wurde das Standardverhalten mit R 4.0 umgestellt, allerdings empfiehlt
sich die explizite Setzung von <code>stringsAsFactors=F</code> trotzdem, damit der Code
auch mit älteren Versionen gut funktioniert.]</p>
<pre><code class="language-r">df_4 &lt;- data.frame(
  &quot;gender&quot; = c(rep(&quot;male&quot;, 3), rep(&quot;female&quot;, 2)),
  &quot;height&quot; = c(189, 175, 180, 166, 150),
  stringsAsFactors = FALSE
)
df_4
</code></pre>
<pre><code>##   gender height
## 1   male    189
## 2   male    175
## 3   male    180
## 4 female    166
## 5 female    150
</code></pre>
<p>Data Frames sind das klassische Objekt um eingelesene Daten zu repräsentieren.
Wenn Sie sich z.B. Daten zum BIP in Deutschland aus dem Internet runterladen und
diese Daten dann in R einlesen, werden diese Daten zunächst einmal als <code>data.frame</code>
repräsentiert.^[Das ist nicht ganz korrekt, weil es mittlerweilse Erweiterungen
gibt, welche den <code>data.frame</code> mit effizienteren Objekten ersetzen, z.B. dem
<code>tibble</code> oder dem <code>data.table</code>. Der Umgang mit diesen Objekten ist jedoch
sehr ähnlich zum <code>data.frame</code>.]
Diese Repräsentation erlaubt dann eine einfache Analyse und Manipulation der Daten.</p>
<p>Zwar gibt es ein eigenes Kapitel zur Bearbeitung von Daten
(siehe Kapitel <a href="#data"><strong>??</strong></a>), wir wollen aber schon hier einige zentrale Befehle
im Zusammenhang von Data Frames einführen.</p>
<p>An dieser Stelle sei schon angemerkt, dass um Zeilen, Spalten oder
einzelne Elemente auszuwählen die gleichen Befehle wie bei Matrizen
verwendet werden können:</p>
<pre><code class="language-r">df_4[, 1] # Werte der ersten Spalte
</code></pre>
<pre><code>## [1] &quot;male&quot;   &quot;male&quot;   &quot;male&quot;   &quot;female&quot; &quot;female&quot;
</code></pre>
<pre><code class="language-r">df_4[, 2] # Werte der zweiten Spalte
</code></pre>
<pre><code>## [1] 189 175 180 166 150
</code></pre>
<p>Die Abfrage funktioniert nicht nur mit Indices, sondern auch mit
Spaltennamen:^[
Anstelle von <code>[[</code> kann auch der Shortcut <code>$</code> verwendet werden. Das werden wir
aufgrund der größeren Transparenz von <code>[[</code> hier jedoch nicht verwenden.]</p>
<pre><code class="language-r">df_4[[&quot;gender&quot;]] 
</code></pre>
<pre><code>## [1] &quot;male&quot;   &quot;male&quot;   &quot;male&quot;   &quot;female&quot; &quot;female&quot;
</code></pre>
<p>Wenn wir <code>[</code> anstatt von <code>[[</code> verwenden erhalten wir als Output einen (reduzierten)
Data Frame:</p>
<pre><code class="language-r">df_4[&quot;gender&quot;] 
</code></pre>
<pre><code>##   gender
## 1   male
## 2   male
## 3   male
## 4 female
## 5 female
</code></pre>
<p>Es können auch mehrere Zeilen ausgewählt werden:</p>
<pre><code class="language-r">df_4[1:2, ] # Die ersten beiden Zeilen
</code></pre>
<pre><code>##   gender height
## 1   male    189
## 2   male    175
</code></pre>
<p>Oder einzelne Werte:</p>
<pre><code class="language-r">df_4[2, 2] # Zweiter Wert der zweiten Spalte
</code></pre>
<pre><code>## [1] 175
</code></pre>
<p>Dies können wir uns zu Nutze machen um den Typ der einzelnen Spalten
herauszufinden:</p>
<pre><code class="language-r">typeof(df_4[[&quot;gender&quot;]])
</code></pre>
<pre><code>## [1] &quot;character&quot;
</code></pre>
<p>Gerade bei sehr großen Data Frames möchte man oft nur die ersten paar Zeilen
inspizieren.
Das ist mit der Funktion <code>head()</code> möglich.
Das erste Argument ist immer der Name des Data Frames.
Das zweite (optionale) Argument ist ein <code>integer</code>, der die Anzahl der
anzuzeigenden Zeilen angibt (Standardwert: <code>5</code>):</p>
<pre><code class="language-r">head(df_4, 2) # gibt die ersten zwei Zeilen aus
</code></pre>
<pre><code>##   gender height
## 1   male    189
## 2   male    175
</code></pre>

</main>

  <footer>
  <script defer src="//yihui.org/js/math-code.js"></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script defer src="//yihui.org/js/center-img.js"></script>

  
  <hr/>
  © <a href="https://claudius-graebner.com/">Claudius Gräbner-Radkowitsch</a> 2021 &ndash; 2022 | <a href="https://www.uni-flensburg.de/en/pluralist-economics">EUF</a> | <a href="https://github.com/graebnerc">Github</a> | <a href="https://twitter.com/ClaudiusGrabner">Twitter</a> | <a href="https://orcid.org/0000-0003-4065-4722">OrcID</a>
  
  </footer>
  </body>
</html>

